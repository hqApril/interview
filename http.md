1. 什么是`RESTful`

   REST就是Representational State transfer 表述性状态转移，就是对资源的表述性状态转移；

   REST是一种设计架构的原则与规范，符合REST原则的架构即可称为RESTful

   REST架构的核心原则：统一接口

   主要原则

   * 网络上的所有事物都被抽象为资源
* 每个资源都具有唯一的资源标识符
   * 同一个资源具有多种表现形式
* 对资源的操作不会改变资源标识符
   * 所有的操作都是无状态的

2. 从输入url到页面展示的过程
    1. dns解析
    2. tcp三次握手
    3. 发送请求，分析url，设置请求报文
    4. 服务器返回html文件
    5. 浏览器渲染
        * HTML parser --> DOM Tree 构建dom树
        * CSS parser --> Style Tree 构建样式树
        * attachment --> Render Tree 结合dom树和style树，生成渲染树
        * layout布局，GPU绘制页面
    
3. 什么是XSS跨站脚本攻击

    xss跨站脚本攻击简单来说，就是攻击者想尽一切办法把可执行的代码嵌入到页面中，以达到非法窃取某些数据或者破坏的目的，根据场景不同，XSS攻击可分为几种类型：

    > **反射型**
    >
    > 反射型也称为非持久性XSS攻击，是指发生请求时，XSS代码会出现在请求的url中，作为参数提交到服务器，响应结果中包含XSS代码，最后通过浏览器进行解析并执行，一个反射型XSS可能如下所示：
    >
    > ```javascript
    > function ajax(url) {
    >     return new Promise((resolve, reject) => {
    >         setTimeout(() => {
    >             resolve(url.split('?')[1]);
    >         }, 1500);
    >     });
    > }
    > 
    > var url = 'https://www.baidu.com/getUserInfo?name=<script>alert(document.cookie)</script>';
    > 
    > ajax(url).then((data) => {
    >    document.body.inerAdjacentHTML('beforeEnd', data.split('=')[1]); 
    > });
    > ```
    >
    > **存储型**
    >
    > 存储型也称持久型XSS，它的主要攻击方式是将代码发送到服务器，最常见的存储型XSS攻击就是评论或者浏览攻击，一个存储型XSS可能如下图：
    >
    > ![存储型XSS](https://wangtunan.github.io/blog/assets/img/12.5c4e51ca.png)

    XSS防御

    >1. 将用户输入的内容，进行必要的标签转义，包括`<`、`>`、`/`等；
    >2. 在服务器端设置`cookie`属性为`httpOnly`防止客户端通过document.cookie读取；
    >3. 过滤一些危险字符串，例如`onerror`、`href`、`script`、`src`等；

4. CSP安全策略

    CSP安全策略本质上来说就是建立白名单机制，告诉浏览器哪些外部资源可以加载和执行，我们只需要配置，拦截主要交给浏览器；

    通常有两种方法设置CSP：

    >1. 通过设置`HTTP Header`的`Content-Security-Policy`
    >2. 通过`meta`标签来设置，例如：`<meta http-equiv="Content-Security-Policy" content="策略">`

5. CSRF跨域请求伪造

    CSRF攻击原理上是攻击者伪造一个后端请求地址，诱导用户进行点击，如果用户在已登录的情况下点击了这个危险链接，则后端服务器会认为用户在正常访问，攻击者可以从请求中拿到一些信息，进而进行攻击；

    CSRF防御

    >1. `get`请求不对数据进行修改
    >2. 不让第三方网站访问用户的cookie，可以通过cookie的SameSite属性
    >3. 阻止第三方网站请求
    >4. 进行请求时，附加`refer`验证和`token`验证；抵御CSRF攻击的关键在于，在请求中放入攻击者所不能伪造的信息，并且该信息总不存在于cookie之中；鉴于此，系统开发人员可以在http请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token不正确，则认为该请求是CSRF攻击；

6. 点击劫持

    点击劫持是一种视觉欺骗手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击；

    防御手段

    >设置http响应头`X-FRAME-OPTIONS`，它可以设置`DENY`、`SAMEORIGIN`、`ALLOW-FROM`分别表示不允许iframe展示、只允许同源iframe展示、指定域名iframe展示；

7. 中间人攻击

    中间人攻击时攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了；攻击者不仅能获取到双方的通信信息，还能修改通信信息；一般来说使用`https`协议可以有效防止中间人攻击，但并不是说`https`就可以高枕无忧，因为攻击者可以通过某种方式从`https`降级到`http`进行访问；

    ![中间人攻击](https://wangtunan.github.io/blog/assets/img/13.d8ae3b54.jpg)
    
8. http协议基础

    * **永远都是客户端发起请求，服务端回送响应** 应用http协议是，必定是一端担任客户端角色，另一端担任服务端角色；仅从一条通信线路来说，客户端和服务端的角色都是固定的；http协议规定，请求从客户端发出，最后服务端响应该请求并返回；换句话说，肯定是从客户端先建立通信的，服务端在没有收到请求之前不会发送响应；
    * **http是一种无状态协议，协议本身不对请求和响应之间的通信状态进行保存** 也就说在http这个级别，协议对于发送过的请求或响应都不做持久化处理；这是为了更快地处理大量事务，确保协议地可伸缩性，而特意把http协议设计成如此简单地；可是随着web地不断发展，我们的很多业务都需要对通信状态进行保存，于是我们引进了cookie技术；有了cookie再用http协议通信，就可以管理状态了；
    * **cookie管理状态** cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态；cookie会根据从服务端发送来的一个叫`Set-Cookie`的首部字段信息，通知客户端保存cookie；当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入cookie值后发送出去；服务器发现客户端发送过来的cookie后，会去检查究竟是哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息；
    * **uri定位资源** http协议使用uri定位互联网上的资源；正是因为uri的特定功能，在互联网上任意位置的资源都能访问到；
    * **持久连接** http协议的初始版本中，每进行一个http通信都要断开一次tcp连接；比如使用浏览器浏览一个包含多张图片的html页面时，在发送请求访问html页面资源的同时，也会请求该html页面里包含的其它资源；因此，每次请求都会造成无谓的tcp连接断开与建立，增加通信量的开销；为了解决上述tcp连接的问题，http/1.1和部分http/1.0相处了持久连接的方法；其特点是，只要任意一端没有明确提出断开连接，则保持tcp连接状态；旨在建立一次tcp连接后进行多次请求和响应交互；在http/1.1中，所有的连接默认都是持久连接；
    * **管线化** 持久连接使得多数请求以管线化方式发送成为可能；以前发送请求后需等待并接收响应；管线化技术出现后，不用等待亦可发送下一个请求；这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了；比如，当请求一个包含了多张图片地html页面时，与挨个连接相比，用持久连接可以让请求更快结束；而管线化技术要比持久连接速度更快；请求数越多，时间差就越明显；
    
9. 关于三次握手

    **SYN** Synchronize Sequence Numbers 同步序列编号

    **ACK** Acknowledge Charactor 确认字符

    1. 客户端给服务器发送一个SYN报文；
    2. 服务端收到SYN报文之后，会应答一个SYN+ACK报文；
    3. 客户端收到SYN+ACK报文之后，会回应一个ACK报文；
    4. 服务器收到ACK报文之后，三次握手建立完成；

    三次握手的作用是确认双方的接收与发包能力是否正常；

10. 为什么需要三次握手

    第一次握手：客户端发送网络包，服务端收到了，这样子服务端就能得出结论，客户端的发送能力，服务端的接收能力是正常的；

    第二次握手：服务端发送网络包，客户端收到了，这样子客户端就能得出结论，客户端的发送能力、接收能力，服务端的发送能力、接收能力都是正常的；

    第三次握手：客户端发送网络包，服务端收到了，这样子服务端就得出结论，客户端的发送能力、接受能力，服务端的发送能力，接收能力都是正常的；

    因此，需要三次握手才能确认双发的接收与发送能力都是正常的

11. http常见状态码

     * 1xx 信息性状态码，表示请求正在处理
     * 2xx 成功状态码，表示请求处理完毕
     * 3xx 重定向状态码，表示需要附加操作以完成请求
     * 4xx 客户端错误状态码，服务器无法处理请求
     * 5xx 服务端错误状态码，服务器处理请求出错

12. http的缓存机制

     > **强缓存**
     >
     > 与强缓存有关的字段有两个`Expires`和`Cache-Control`
     >
     > `Expires`字段规定了缓存的资源的过期时间，在此时间之前，缓存中的资源都是有效的，该字段的value是一个格林威治时间`GMT`，即世界标准时间，js通过`new Date().toUTCString()`可得到，形式如`Tue, 27 Feb 2018 06:37:48 GMT`；它的缺点很明显，时间期限是由服务器生成的，存在客户端和服务器的时间误差，固定时间，HTTP 1.0时的规范，相比较Cache-Control，优先级较低；
     >
     > `Cache-Control`最常用的值是max-age，单位为s，对比`Expires`体现着一个相对时间，即多少秒后这个强缓存机制下的缓存资源失效；
     >
     > 如果Cache-Control设置为no-cache，并不是说，不准使用缓存，而是需要走接下来的优先级相对较低的另一类--协商缓存；真正决定不使用缓存内的资源是将该值定义为`no-store`；
     >
     > **协商缓存**
     >
     > 协商缓存是通过客户端与服务端进行http通信时，所在响应头和请求头中互相表达”暧昧“的，相互通气，互送缓存标识；
     >
     > `Last-Modified`和`If-Modified-Since`
     >
     > 第一次请求某个资源时，由于一定不会走缓存，所以服务端会在资源的响应头中加上一个形如`Last-Modified:Mon, 26 Feb 2018 06:37:41 GMT`的字段告诉客户端，这个资源上次最后修改的时间；刷新页面再次请求，这时候的协商缓存就会在请求头中加上一个`If-Modified-Since`，表示是否在上个时间之后修改了，值就是服务器上次响应给它的时间，让服务器去判断是否在此时间之后资源内容发生了变化；
     >
     > 如果服务器发现改变了资源，就伴随200的状态码和新鲜的资源给客户端，如果没有修改，那么就发送一个204状态码，让客户端从缓存中取资源；
     >
     > `Etag`和`If-None-Match`
     >
     > 该组合的优先级大于上面的组合，有些周期性修改的资源，可能资源本身内容并没有发生改变，这时候，Etag就比Last-Modified合理了

13. 随着http2的发展，前端性能优化中哪些传统法案可以被替代

     * 雪碧图
     * 资源文件合并

14. http2和http1有什么不同

     * 多路复用
     * 二进制帧
     * server push
     * 头部压缩

15. 可以对图片开启gzip压缩吗

     不需要开启，如果开启的话，有可能图片会变得更大；

16. http工作过程

     > **地址解析**
     >
     > 如果客户端浏览器请求页面`localhost:8080/index.html`从中分解出协议名、主机名、端口、对象路径等部分，对于我们这个地址，解析得到的结果如下
     >
     > ```
     > 协议名：http
     > 主机名：localhost
     > 端口：8080
     > 对象路径：/index.html
     > ```
     >
     > 在这一步，还需要域名系统DNS来解析域名，得到主机的ip地址
     >
     > **封装http请求数据包**
     >
     > 把上面部分结合本机自己的信息，封装成一个http请求包
     >
     > **封装成tcp包，建立tcp连接**
     >
     > 在http工作开始之前，客户端首先要通过网络与服务器建立连接，该连接时通过tcp来完成的，该协议与ip协议共同构成了internet，即著名的TCP/IP协议族，因此Internet网络又被称作TCP/IP网络；http是比tcp更高层次的应用层协议，根据规则，只有底层协议建立后才能进行更高层协议的链接，因此，首先要建立tcp连接，一般tcp连接的端口号是80；
     >
     > **客户端向服务器发送请求命令**
     >
     > 建立tcp连接之后，客户端会发送一个请求给服务端，请求的方式的格式为，统一资源标识符、协议版本好、后面是MIME信息包括请求修饰符、客户机信息和内容等；
     >
     > **服务器响应**
     >
     > 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括协议版本号、一个成功或者错误的状态码，后面是MIME信息包括服务器信息、实体信息和可能的内容；
     >
     > 实体信息是服务器向浏览器发送头信息后，他会发送一个空白行来表示头信息的发送到此结束，接着它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据；
     >
     > **服务器关闭tcp连接**
     >
     > 一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭tcp连接，然后如果客户端在其头信息中加入了这行代码`Connect: keep-alive`，tcp连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求；保持连接节省了为每个请求建立新连接的时间，还节约了网络带宽；

17. http的缺点

     * 通信使用明文，容易被窃听
     * 不验证通信方的身份，可能遭遇伪装
     * 无法验证报文的完整性，可能遭遇篡改

18. https缺点

     * https协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电
     * https连接缓存不如http高效，如果是大浏览网站，则会造成浏览成本太高
     * https连接服务器资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用https，给予大部分计算资源闲置的假设的VPS的平均成本会上去；
     * ssl证书需要钱
     * ssl证书通常需要绑定ip，不能在同一个ip上绑定多个域名

19. https接入优化

     > **cdn接入**
     >
     > https增加的延时时间主要是传输延时RTT，RTT的特点是节点越近延时越小，cdn天然离用户最近，因此选择使用cdn作为https接入的接口，将能够极大地减少接入延时；cdn节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少https带来地延时；
     >
     > **会话缓存**
     >
     > 给予会话缓存建立地https连接不需要服务器使用RSA密钥回去Pre-master信息，可以省去cpu的消耗；如果业务方法连接几种，缓存命中率高，则https的接入能力将明显提升；当前trp平台的缓存命中率高峰时期大于30%，10k/s的接入资源实际可以承载13k/s的接入，收效非常可观；
     >
     > **硬件加速**
     >
     > 为接入服务器安装装用的ssl硬件加速卡，可以提升ssl加密解密的速度；
     >
     > **远程解密**
     >
     > 本地接入消耗了过多的cpu资源，浪费了网卡和硬盘等资源，考虑将最消耗cpu资源的rsa解密计算任务转移到其它服务器，这样子可以充分发挥服务器的接入能力，充分利用带宽和网卡资源；
     >
     > **http2**
     >
     > http2利用tls/ssl带来的优势，通过修改协议的方式来提升https的性能，提高下载速度；
